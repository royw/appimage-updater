version: '3'

vars:
  SRC: src/
  TESTS: tests/
  PYTHON_VERSIONS:
    sh: cat .python-versions | grep -v '^$' | tr '\n' ' ' | sed 's/[[:space:]]*$//'
  PYTHON_VERSION:
    sh: cat .python-version | head -n1
  TEST_TIMEOUT: 30
  # Global emoji replacements dictionary - single source of truth
  # Format: "emoji:replacement emoji:replacement ..."
  # Used by both lint:emoji (keys) and fix:emoji (full mapping)
  EMOJI_REPLACEMENTS_MAP: '✅:PASS ❌:FAIL ⚠️:WARNING 🔍:SEARCH 📦:PACKAGE 🐧:LINUX 🚀:DEPLOY 🎯:TARGET 🏆:SUCCESS 🎉:COMPLETE 📊:REPORT 🧪:TEST 🔴:HIGH 🟡:MEDIUM 🟢:LOW 📚:DOCS 🌍:SERVER 🏗️:BUILD 📈:BUMP 📝:COMMIT 🐍:PYTHON 📋:LIST ✓:DONE 📁:FOLDER 🌐:NETWORK 🎭:MOCK ⚡:EXECUTE 📤:STDOUT 📥:STDERR 💥:EXCEPTION 🔧:VERSION 📄:FILE 🌳:TREE 🏁:COMPLETE 🔒:LOCK 🔓:UNLOCK 🐛:BUG 🛠️:TOOLS 🚨:0'

tasks:
# === Default ===
  default:
    desc: Show available tasks
    cmds:
      - task --list --sort none

# === Internal ===
  _output:
    desc: Internal task to output messages silently
    cmds:
      - cmd: echo "{{.MESSAGE}}"
        silent: true

  # === Setup and Environment ===
  
  # Environment validation
  env:check:
    desc: Verify development environment setup
    cmds:
      - task: _output
        vars:
          MESSAGE: "Checking Prerequisite versions..."
      - uv --version
      - uv run python --version
      - git --version
      - pipx --version
      - pymarkdownlnt version

  install:
    desc: Install project dependencies (first-time setup) into .venv/
    deps:
      - env:check
      - sync

  sync:
    desc: Sync project dependencies with uv into .venv/
    cmds:
      - uv sync --extra dev

  resync:
    desc: Resync project dependencies by first deleting .venv/ and then syncing with uv into .venv/
    cmds:
      - rm -rf .venv/
      - task: sync

  clean:
    desc: Clean up generated files
    cmds:
      - find . -type d -name "__pycache__" -exec rm -rf {} +
      - find . -type f -name "*.pyc" -delete
      - rm -rf .mypy_cache/
      - rm -rf .pytest_cache/
      - rm -rf dist/
      - rm -rf build/
      - rm -rf site/

  # === Code Quality ===
  format:
    desc: Format code with ruff (including import sorting) and format markdown files with mdformat
    cmds:
      - uv run ruff check --fix --select I {{.CLI_ARGS | default .SRC}}  # Fix import sorting
      - uv run ruff format {{.CLI_ARGS | default .SRC}}  # Format code
      - cmd: |
          if ! command -v mdformat &> /dev/null; then
            uv tool install mdformat
          fi
        silent: true
      - mdformat {{.CLI_ARGS | default "*.md docs/*.md"}}

  format:tests:
    desc: Format tests with ruff (including import sorting)
    deps:
      - lint:fix:tests
    cmds:
      - uv run ruff format {{.CLI_ARGS | default .TESTS}}  # Format code

  fix:emoji:
    desc: Remove emojis from markdown and test files (*.md, docs/*.md, tests/*.py)
    cmds:
      - cmd: |
          python3 << 'PYTHON_SCRIPT'
          import os
          import glob
          from pathlib import Path
          
          # Build emoji replacements map from Taskfile variable
          EMOJI_MAP = '{{.EMOJI_REPLACEMENTS_MAP}}'
          
          # Parse the map into a dictionary
          replacements = {}
          for pair in EMOJI_MAP.split():
              if ':' in pair:
                  emoji, replacement = pair.split(':', 1)
                  replacements[emoji] = replacement
          
          print("Removing emojis from markdown and test files...")
          
          def process_file(filepath):
              """Process a single file and replace emojis."""
              try:
                  with open(filepath, 'r', encoding='utf-8') as f:
                      content = f.read()
                  
                  original_content = content
                  
                  # Apply all emoji replacements
                  for emoji, replacement in replacements.items():
                      content = content.replace(emoji, replacement)
                  
                  # Only write if content changed
                  if content != original_content:
                      with open(filepath, 'w', encoding='utf-8') as f:
                          f.write(content)
                      print(f"  - Emojis removed from {filepath}")
              except Exception as e:
                  print(f"  ! Error processing {filepath}: {e}")
          
          print("Processing markdown files...")
          # Process markdown files in project root (max depth 1)
          for md_file in glob.glob("*.md"):
              process_file(md_file)
          
          # Process markdown files in docs/ directory
          if os.path.isdir("docs"):
              for md_file in Path("docs").rglob("*.md"):
                  process_file(str(md_file))
          
          print("Processing test Python files...")
          # Process all test python files (including subdirectories)
          if os.path.isdir("tests"):
              for py_file in Path("tests").rglob("*.py"):
                  process_file(str(py_file))
          
          print("Emoji removal complete!")
          PYTHON_SCRIPT
        silent: true

  # === Linting ===
  lint:
    desc: Run all linting tasks
    cmds:
      - task: lint:fix
      - task: lint:ruff
      - task: lint:mypy
      - task: lint:markdown
      - task: lint:emoji
      - task: lint:deadcode

  lint:ruff:
    desc: Run linting with ruff
    cmds:
      - uv run ruff check {{.CLI_ARGS | default .SRC}}

  lint:fix:
    desc: Automatically fix linting issues with ruff
    cmds:
      - uv run ruff check --fix --select I {{.CLI_ARGS | default .SRC}}

  lint:fix:tests:
    desc: Automatically fix linting issues with ruff
    cmds:
      - uv run ruff check --fix --select I {{.CLI_ARGS | default .TESTS}}

  lint:emoji:
    desc: Search for emojis in source code, docs, and configuration files
    cmds:
      - cmd: |
          echo "SEARCH Searching for emojis in codebase..."
          EMOJI_FOUND=0
          
          # Extract emoji keys from global EMOJI_REPLACEMENTS_MAP
          EMOJI_MAP='{{.EMOJI_REPLACEMENTS_MAP}}'
          
          # Extract just the emojis (keys before the colon)
          EMOJI_LIST=$(echo "$EMOJI_MAP" | tr ' ' '\n' | cut -d':' -f1)
          
          # Search in source code
          if echo "$EMOJI_LIST" | xargs -I {} grep -rn --include="*.py" -F {} src/ 2>/dev/null; then
            echo "FAIL Emojis found in source code (src/)"
            EMOJI_FOUND=1
          fi
          
          # Search in tests
          if echo "$EMOJI_LIST" | xargs -I {} grep -rn --include="*.py" -F {} tests/ 2>/dev/null; then
            echo "FAIL Emojis found in tests (tests/)"
            EMOJI_FOUND=1
          fi
          
          # Search in docs
          if echo "$EMOJI_LIST" | xargs -I {} grep -rn --include="*.md" -F {} docs/ 2>/dev/null; then
            echo "FAIL Emojis found in documentation (docs/)"
            EMOJI_FOUND=1
          fi
          
          # Search in README.md
          if echo "$EMOJI_LIST" | xargs -I {} grep -rn -F {} README.md 2>/dev/null; then
            echo "FAIL Emojis found in README.md"
            EMOJI_FOUND=1
          fi
          
          # Search in mkdocs.yml
          if echo "$EMOJI_LIST" | xargs -I {} grep -rn -F {} mkdocs.yml 2>/dev/null; then
            echo "FAIL Emojis found in mkdocs.yml"
            EMOJI_FOUND=1
          fi
          
          if [ $EMOJI_FOUND -eq 0 ]; then
            echo "PASS No emojis found in codebase"
          else
            echo "FAIL Emoji check failed - emojis found in codebase"
            exit 1
          fi
        silent: true

  lint:mypy:
    desc: Run type checking with mypy
    cmds:
      - uv run mypy {{.CLI_ARGS | default .SRC}}

  lint:markdown:
    desc: Lint markdown files with pymarkdownlnt
    cmds:
      - cmd: |
          if ! command -v pymarkdownlnt &> /dev/null; then
            uv tool install pymarkdownlnt
          fi
        silent: true
      - uv run pymarkdownlnt --config .pymarkdown.json scan {{.CLI_ARGS | default "*.md docs/*.md"}} || true

  lint:deadcode:
    desc: Find dead (unreachable/unused) code with deadcode
    cmds:
      - cmd: echo "Checking deadcode..."
        silent: true
      - >
        uv run deadcode {{.CLI_ARGS | default .SRC}}
        --ignore-if-decorated-with "@app.command" "@app.callback" "@field_validator" 
        --ignore-names "main" "main_callback" "check" "edit" "list_apps" "show" "repository" "add" "remove" "config"
        "validate_pattern" "validate_download_dir" "validate_symlink_path" "model_post_init" "validate_paths" "apply_global_defaults_to_config"
        "checked_at" "expected" "actual" "duration_seconds" "message" "timestamp" "codename" "distribution_family"
        "print_progress" "print_success" "print_error" "print_warning" "print_info" "print_config_settings"
        "generate_pattern_from_releases" "_try_parse_last_modified_header" "_try_parse_date_header"
        "_extract_version_from_filename" "excepthook" "_print_troubleshooting_tips"
        "_handle_edit_preview_modes" "_apply_edit_updates_to_apps" "supported_domains"
    silent: true

  # === Metrics ===
  metrics:
    desc: Display comprehensive project metrics summary
    cmds:
      - bash scripts/metrics.sh

  complexity:
    desc: Analyze code complexity with radon
    cmds:
      - cmd: echo "Checking complexity..."
        silent: true
      - uv run radon cc {{.CLI_ARGS | default .SRC}} --min B

  # === Testing ===
  test:
    desc: Run tests with pytest (sequential) - excludes regression tests - full coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/unit tests/functional tests/integration tests/e2e {{.CLI_ARGS}}

  test:parallel:
    desc: Run tests with pytest - unit/functional/integration in parallel, E2E serially - excludes regression tests - summary coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/unit tests/functional tests/integration -n auto {{.CLI_ARGS}} 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/e2e {{.CLI_ARGS}} 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"

  test:unit:
    desc: Run unit tests only - summary coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/unit/ {{.CLI_ARGS}} 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"

  test:functional:
    desc: Run functional tests only - summary coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/functional/ {{.CLI_ARGS}} 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"

  test:integration:
    desc: Run integration tests only - summary coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/integration/ {{.CLI_ARGS}} 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"

  test:e2e:
    desc: Run end-to-end tests to validate core functionality (serially for test isolation) - summary coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/e2e/ -v --tb=short --color=yes --no-cov 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"

  test:pattern-matching:
    desc: Test pattern matching functionality specifically - summary coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/e2e/test_pattern_matching.py -v 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/unit/test_intelligent_pattern_generation.py -v 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"

  test:regression:
    desc: Run regression tests to validate fixed issues (uses network) - full coverage reporting
    cmds:
    # do not use timeout here as it will cause the test to fail
      - uv run pytest tests/regression/ -v --tb=short --color=yes
      - task: _output
        vars:
          MESSAGE: "✅ Regression tests passed - fixed issues remain resolved!"

  test:all:
    desc: Run all tests against all Python versions (excludes regression) - summary coverage reporting
    cmds:
      - cmd: echo "🐍 Running tests against all Python versions..."
        silent: true
      - for:
          var: PYTHON_VERSIONS
          split: ' '
        cmd: |
          echo "📋 Testing with Python {{.ITEM}}"
          uv run --python {{.ITEM}} pytest --timeout {{.TEST_TIMEOUT}} tests/unit tests/functional tests/integration tests/e2e --tb=short --color=yes 2>&1 | grep -Pv "^src/\S+\s+\d+\s+\d+\s+\d+%$"
      - cmd: echo "✅ All Python versions tested successfully!"
        silent: true

  test:coverage:
    desc: Run all tests with coverage reporting (excludes regression tests) - full coverage reporting
    cmds:
      - uv run pytest --timeout {{.TEST_TIMEOUT}} tests/unit tests/functional tests/integration tests/e2e --cov={{.SRC}}appimage_updater --cov-report=xml --cov-report=term-missing --cov-report=html:htmlcov
      - task: _output
        vars:
          MESSAGE: "📊 Coverage report saved to htmlcov/index.html"

  # === Documentation ===
  docs:build:
    desc: Build documentation with MkDocs
    cmds:
      - task: _output
        vars:
          MESSAGE: "📚 Building documentation..."
      - uv run mkdocs build {{.CLI_ARGS}} 2>&1 | grep -v "MERMAID2.*Found superfences config" | grep -v "MERMAID2.*Initialization arguments" | grep -v "MERMAID2.*Using javascript library" || true
      - task: _output
        vars:
          MESSAGE: "✅ Documentation built successfully in site/"

  docs:serve:
    desc: Serve documentation locally for development
    cmds:
      - task: _output
        vars:
          MESSAGE: "🌍 Starting documentation server..."
      - uv run mkdocs serve {{.CLI_ARGS}}

  docs:
    desc: Build and serve documentation locally
    deps:
      - docs:build
      - docs:serve

  # === Version ===
  version:pyproject:
    desc: Extract version from pyproject.toml (internal task)
    cmds:
      - python3 -c "import tomllib; f = open('pyproject.toml', 'rb'); data = tomllib.load(f); f.close(); print(data['project']['version'])"
    silent: true

  version:
    desc: Display the current project version
    cmds:
      - task: _output
        vars:
          MESSAGE: "v$(task version:pyproject)"

  # === Build Packages ===

  build:
    desc: Build distribution packages
    deps:
      - clean
    cmds:
      - task: _output
        vars:
          MESSAGE: "🏗️  Building AppImage Updater distribution packages..."
      - uv build {{.CLI_ARGS}}
      - task: _output
        vars:
          MESSAGE: "✅ Build complete! Packages created in dist/"
      - ls -la dist/

# === Development Workflow ===

  # === Quality Checks ===
  check:
    desc: Run all code quality checks including end-to-end tests
    cmds:
      - task: fix:emoji
      - task: format
      - task: lint
      - task: complexity
      - task: test:parallel

  # === Build and Release ===
  make:
    desc: Complete build pipeline - run all checks, build, docs, and show version
    cmds:
      - task: _output
        vars:
          MESSAGE: "🚀 Starting build pipeline..."
      - task: check
      - task: build
      - task: docs:build
      - task: version
      - task: _output
        vars:
          MESSAGE: "✅ Build pipeline completed successfully! Ready to push to GitHub 🎉"

  version:bump:
    desc: Bump the patch version, build, and commit changes
    cmds:
      - task: _output
        vars:
          MESSAGE: "🔍 Checking for uncommitted changes..."
      - |
        if [ -n "$(git status --porcelain)" ]; then
          task output MESSAGE="❌ Error: There are uncommitted changes. Please commit or stash them first."
          git status --short
          exit 1
        else
          task output MESSAGE="✅ Working directory is clean"
        fi
      - task: _output
        vars:
          MESSAGE: "📈 Bumping version..."
      - uv run version_bumper bump patch
      - task: _output
        vars:
          MESSAGE: "✅ Version bumped! New version:"
      - task: version
      - task: _output
        vars:
          MESSAGE: "🏗️  Building package..."
      - task: build
      - task: _output
        vars:
          MESSAGE: "📝 Committing version bump..."
      - |
        NEW_VERSION=$(task version:pyproject)
        git add pyproject.toml
        git commit -m "chore: bump version to v$NEW_VERSION"
        task output MESSAGE="✅ Committed version bump to v$NEW_VERSION"

  deploy:
    desc: Deploy the built package locally with pipx
    deps:
      - build
    cmds:
      - task: _output
        vars:
          MESSAGE: "🚀 Installing locally with pipx..."
      - pipx install --force dist/*.whl
      - task: _output
        vars:
          MESSAGE: "✅ Successfully deployed appimage-updater v$(task version) locally!"

  version:tag:
    desc: Create and push a git tag for the current version
    deps:
      - version
    cmds:
      - cmd:  VERSION=$(task version:pyproject)
        silent: true
      - task: _output
        vars:
          MESSAGE: "Creating tag v$VERSION..."
      - cmd:  git tag "v$VERSION"
      - cmd:  git push origin "v$VERSION"
      - task: _output
        vars:
          MESSAGE: "✅ Tag v$VERSION created and pushed to origin!"

  # === CI/CD Pipeline ===
  ci:
    desc: Run GitHub CI build locally using scripts/ci-local.sh.  This is the same pipeline that runs on GitHub Actions.
    cmds:
      - bash scripts/ci-local.sh

  # === Development and Running ===
  run:
    desc: Run the application
    cmds:
      - uv run python -m appimage_updater {{.CLI_ARGS}}
